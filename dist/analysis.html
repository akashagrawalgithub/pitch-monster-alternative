<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Training Analysis Report</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
  <link rel="stylesheet" crossorigin href="/assets/analysis-WFiPAMat.css">
</head>

<body>
    <div class="container">
        <!-- Left Sidebar - Chat Transcript -->
        <div class="transcript-sidebar">
            <!-- <div class="transcript-header">
                <div class="session-info">
                    <div class="session-avatar">ðŸŽ¯</div>
                    <div class="session-details">
                        <h3>Session Details</h3>
                        <p>Analysis & Transcript</p>
                    </div>
                </div>
                <div class="session-stats">
                    <span id="sessionDuration">Duration: --</span>
                    <span id="sessionExchanges">Exchanges: --</span>
                </div>
            </div> -->

            <!-- Voice Recording Player -->
            <div class="recording-player" id="recordingPlayer" style="display: none;">
                <div class="audio-controls">
                    <div class="audio-progress" id="audioProgress">
                        <div class="audio-progress-fill" id="audioProgressFill"></div>
                        <div class="audio-tooltip" id="audioTooltip">00:00</div>
                    </div>
                    <div class="audio-controls-row">
                        <button class="seek-btn" id="backwardBtn">
                            <span class="material-icons">replay_5</span>
                        </button>
                        <button class="play-btn" id="playBtn">
                            <span class="material-icons" id="playIcon">play_arrow</span>
                        </button>
                        <button class="seek-btn" id="forwardBtn">
                            <span class="material-icons">forward_5</span>
                        </button>
                    </div>
                    <div class="audio-time" id="audioTime">00:00</div>
                </div>
            </div>

            <div class="transcript-list" id="transcriptList">
                <!-- Transcript items will be populated here -->
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="report-header">
                <div class="session-info-main">
                    <div class="session-title-section">
                        
                        <div class="session-meta">
                            
                            <span id="sessionStage">Stage: --</span>
                            <span>â€¢</span>
                            <span id="sessionRole">Role: --</span>
                        </div>
                        <div class="session-stats-main">
                            <span id="sessionDate">Session completed on --</span>
                            <span>â€¢</span>
                            <span id="sessionConfidence" style="color: #10b981; font-weight: 500;">Confidence: --</span>
                        </div>
                    </div>
                </div>
                <div class="overall-score">
                    <div>
                        <div class="score-value" id="overallScore">Overall Score: --</div>
                    </div>
                    <button class="perfect-pitch-btn" id="perfectPitchBtn">
                        <span class="material-icons">auto_awesome</span>
                        Get Perfect Pitch
                    </button>
                </div>
            </div>

            <!-- Conversation Flow Analysis -->
            <div class="conversation-flow">
                <div class="section-header">
                    <div class="section-icon"
                        style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white;">
                        <span class="material-icons">timeline</span>
                    </div>
                    <h3 class="section-title">Sales Process Flow</h3>
                </div>
                <div class="flow-steps">
                    <div class="flow-step" id="introStep">
                        <div class="flow-icon">
                            <span class="material-icons">person_add</span>
                        </div>
                        <div class="flow-label">Introduction</div>
                        <div class="flow-score">--</div>
                    </div>

                    <div class="flow-step" id="discoveryStep">
                        <div class="flow-icon">
                            <span class="material-icons">search</span>
                        </div>
                        <div class="flow-label">Discovery</div>
                        <div class="flow-score">--</div>
                    </div>

                    <div class="flow-step" id="presentationStep">
                        <div class="flow-icon">
                            <span class="material-icons">present_to_all</span>
                        </div>
                        <div class="flow-label">Presentation</div>
                        <div class="flow-score">--</div>
                    </div>

                    <div class="flow-step" id="objectionStep">
                        <div class="flow-icon">
                            <span class="material-icons">support_agent</span>
                        </div>
                        <div class="flow-label">Objection Handling</div>
                        <div class="flow-score">--</div>
                    </div>

                    <div class="flow-step" id="closeStep">
                        <div class="flow-icon">
                            <span class="material-icons">handshake</span>
                        </div>
                        <div class="flow-label">Close</div>
                        <div class="flow-score">--</div>
                    </div>
                </div>
            </div>
            <!-- Analysis Grid -->
            <div class="analysis-grid">
                <!-- Audio Analysis -->
                <div class="analysis-section audio-analysis">
                    <div class="section-header">
                        <div class="section-icon">
                            <span class="material-icons">mic</span>
                        </div>
                        <h3 class="section-title">Voice & Delivery Analysis</h3>
                    </div>

                    <div class="metric-item" id="grammarMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Grammar & Clarity</div>
                                <div class="metric-description">Proper sentence structure and pronunciation</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill grammar" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>

                    <div class="metric-item" id="fluencyMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Fluency & Flow</div>
                                <div class="metric-description">Smooth speech without interruptions</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill fluency" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>

                    <div class="metric-item" id="confidenceMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Confidence Level</div>
                                <div class="metric-description">Reduced hesitation and uncertainty</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill hesitation" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>

                    <div class="metric-item" id="paceMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Speaking Pace</div>
                                <div class="metric-description">Optimal speed for understanding</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill pace" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>

                    <div class="metric-item" id="enthusiasmMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Enthusiasm</div>
                                <div class="metric-description">Energy and passion in delivery</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill enthusiasm" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>

                    <div class="metric-item" id="clarityMetric">
                        <div class="metric-info">
                            <div>
                                <div class="metric-label-detailed">Message Clarity</div>
                                <div class="metric-description">Clear and understandable communication</div>
                            </div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill clarity" style="width: 0%"></div>
                        </div>
                        <div class="metric-value-detailed">--</div>
                    </div>
                </div>

                <!-- AI-Generated Ratings -->
                <div class="analysis-section ai-ratings">
                    <div class="section-header">
                        <div class="section-icon">
                            <span class="material-icons">psychology</span>
                        </div>
                        <h3 class="section-title">Sales Skills Assessment</h3>
                    </div>

                    <div class="rating-item" id="introRating">
                        <div class="rating-info">
                            <div class="rating-label">Introduction Quality</div>
                            <div class="rating-description">Engaging opening and rapport building</div>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <div class="star-rating">
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                            </div>
                            <div class="rating-score">--</div>
                        </div>
                    </div>

                    <div class="rating-item" id="needAnalysisRating">
                        <div class="rating-info">
                            <div class="rating-label">Need Analysis</div>
                            <div class="rating-description">Discovery questions and understanding</div>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <div class="star-rating">
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                            </div>
                            <div class="rating-score">--</div>
                        </div>
                    </div>

                    <div class="rating-item" id="objectionRating">
                        <div class="rating-info">
                            <div class="rating-label">Objection Handling</div>
                            <div class="rating-description">Addressing concerns effectively</div>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <div class="star-rating">
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                            </div>
                            <div class="rating-score">--</div>
                        </div>
                    </div>

                    <div class="rating-item" id="closingRating">
                        <div class="rating-info">
                            <div class="rating-label">Closing Skills</div>
                            <div class="rating-description">Creating urgency and asking for commitment</div>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <div class="star-rating">
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                                <span class="star">â˜…</span>
                            </div>
                            <div class="rating-score">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Insights Grid -->
            <div class="insights-grid">
                <!-- Strengths -->
                <div class="insights-section strengths">
                    <div class="section-header">
                        <div class="section-icon">
                            <span class="material-icons">check_circle</span>
                        </div>
                        <h3 class="section-title">Key Strengths</h3>
                    </div>
                    <ul class="insights-list" id="strengthsList">
                        <li>Loading analysis...</li>
                    </ul>
                </div>

                <!-- Areas for Improvement -->
                <div class="insights-section improvements">
                    <div class="section-header">
                        <div class="section-icon">
                            <span class="material-icons">warning</span>
                        </div>
                        <h3 class="section-title">Areas for Improvement</h3>
                    </div>
                    <ul class="insights-list" id="improvementsList">
                        <li>Loading analysis...</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Perfect Pitch Modal -->
    <div class="modal-overlay" id="perfectPitchModal">
        <div class="perfect-pitch-modal">
            <div class="modal-header">
                <h2 class="modal-title">
                    <span class="material-icons">auto_awesome</span>
                    An sample perfect pitch
                </h2>
                <button class="modal-close" id="modalClose">
                    <span class="material-icons">close</span>
                </button>
            </div>
            <div class="modal-content" id="modalContent">
                <div class="loading-perfect-pitch">
                    <div class="loading-spinner"></div>
                    <p>Generating your perfect pitch...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Audio recording variables
        let audioPlayer = null;
        let isPlaying = false;
        let recordingUrl = null;

        // Function to populate transcript from sessionStorage
        function populateTranscript() {
            const transcriptList = document.getElementById('transcriptList');
            const transcriptData = sessionStorage.getItem('chatTranscript');

            if (transcriptData) {
                const transcript = JSON.parse(transcriptData);

                // Calculate session metrics
                calculateSessionMetrics(transcript);

                transcript.forEach((item, index) => {
                    const transcriptItem = document.createElement('div');
                    transcriptItem.className = `transcript-item ${item.sender.toLowerCase()}`;
                    transcriptItem.style.animationDelay = `${index * 0.1}s`;

                    transcriptItem.innerHTML = `
                        <div class="transcript-avatar-small">
                            ${item.sender === 'AI' ? 'ðŸ¤–' : 'ðŸ§‘'}
                        </div>
                        <div class="transcript-content">
                            ${item.text}
                        </div>
                        <div class="transcript-meta">
                            ${item.sender} â€¢ ${item.time}
                        </div>
                    `;

                    transcriptList.appendChild(transcriptItem);
                });

                // Scroll to bottom of transcript
                transcriptList.scrollTop = transcriptList.scrollHeight;
            }
        }

        // Function to calculate session metrics from transcript
        function calculateSessionMetrics(transcript) {
            if (!transcript || transcript.length === 0) return;

            // Try to get actual recording duration first
            const storedDuration = sessionStorage.getItem('recordingDuration');
            let totalSeconds = 0;

            if (storedDuration) {
                // Use actual recording duration
                totalSeconds = parseFloat(storedDuration);
            } else {
                // Fallback to transcript-based duration
                transcript.forEach(item => {
                    const timeParts = item.time.split(':');
                    if (timeParts.length === 2) {
                        const minutes = parseInt(timeParts[0]);
                        const seconds = parseInt(timeParts[1]);
                        totalSeconds = Math.max(totalSeconds, minutes * 60 + seconds);
                    }
                });
            }

            const durationMinutes = Math.floor(totalSeconds / 60);
            const durationSeconds = Math.floor(totalSeconds % 60);
            const durationText = `${durationMinutes}m ${durationSeconds}s`;

            // Calculate exchanges
            const exchanges = transcript.length;

            // Get current date
            const now = new Date();
            const sessionDate = now.toLocaleDateString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });

            // Update UI elements
            const sessionDurationEl = document.getElementById('sessionDuration');
            const sessionExchangesEl = document.getElementById('sessionExchanges');
            const sessionDateEl = document.getElementById('sessionDate');
            const keyMetricsTimeEl = document.querySelector('.metric-card.conversation-time .metric-value');
            const keyMetricsExchangesEl = document.querySelector('.metric-card.exchanges .metric-value');

            if (sessionDurationEl) sessionDurationEl.textContent = `Duration: ${durationText}`;
            if (sessionExchangesEl) sessionExchangesEl.textContent = `Exchanges: ${exchanges}`;
            if (sessionDateEl) sessionDateEl.textContent = `Session completed on ${sessionDate}`;
            if (keyMetricsTimeEl) keyMetricsTimeEl.textContent = durationText;
            if (keyMetricsExchangesEl) keyMetricsExchangesEl.textContent = exchanges;

            // Calculate average response time (simplified)
            const avgResponseTime = exchanges > 1 ? `${Math.round(totalSeconds / exchanges)}s` : '--';
            const keyMetricsResponseEl = document.querySelector('.metric-card.avg-response .metric-value');
            if (keyMetricsResponseEl) keyMetricsResponseEl.textContent = avgResponseTime;
        }

        // Function to setup voice recording player
        function setupRecordingPlayer() {
            const recordingPlayer = document.getElementById('recordingPlayer');
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const audioProgress = document.getElementById('audioProgress');
            const audioProgressFill = document.getElementById('audioProgressFill');
            const audioTime = document.getElementById('audioTime');
            console.log('hasRecording:', sessionStorage.getItem('hasRecording'));
            console.log('conversationRecording:', sessionStorage.getItem('conversationRecording'));
            console.log('recordingDuration:', sessionStorage.getItem('recordingDuration'));

            let recordingData = null;
            let storedDuration = null;

            // First check if we have recording from sessionStorage (new conversations)
            const hasRecording = sessionStorage.getItem('hasRecording');
            if (hasRecording === 'true') {
                recordingData = sessionStorage.getItem('conversationRecording');
                storedDuration = sessionStorage.getItem('recordingDuration');
            }

            // If we have recording data, set up the player
            if (recordingData) {

                console.log('Data preview:', recordingData.substring(0, 100));
                // Check if this is placeholder data
                if (recordingData === 'YXVkaW9fZGF0YV9wbGFjZWhvbGRlcg==' || recordingData === 'audio_data_placeholder') {
                    recordingPlayer.style.display = 'none';
                    return;
                }

                let audioDataUrl = recordingData;

                // Check if it's already a data URL
                if (!recordingData.startsWith('data:audio/')) {
                    // Try to detect the audio format and create proper data URL
                    const isBase64 = /^[A-Za-z0-9+/]*={0,2}$/.test(recordingData);
                    if (isBase64) {
                        // Try different audio formats
                        const audioFormats = [
                            'audio/wav',
                            'audio/mp3',
                            'audio/mpeg',
                            'audio/ogg',
                            'audio/webm',
                            'audio/m4a'
                        ];

                        let audioCreated = false;

                        for (const format of audioFormats) {
                            try {
                                const testUrl = `data:${format};base64,${recordingData}`;
                                const testAudio = new Audio(testUrl);

                                testAudio.addEventListener('canplaythrough', () => {
                                    audioDataUrl = testUrl;
                                    audioCreated = true;
                                }, { once: true });

                                testAudio.addEventListener('error', () => {
                                }, { once: true });

                                // Try to load the audio
                                testAudio.load();

                                // Wait a bit to see if it loads
                                setTimeout(() => {
                                    if (!audioCreated) {
                                    }
                                }, 1000);

                            } catch (error) {
                            }
                        }

                        // If no format worked, default to WAV
                        if (!audioCreated) {
                            audioDataUrl = `data:audio/wav;base64,${recordingData}`;
                        }
                    } else {
                        // Not base64, might be raw audio data
                        audioDataUrl = `data:audio/wav;base64,${btoa(recordingData)}`;
                    }
                }

                recordingPlayer.style.display = 'block';

                // Create audio element from data URL
                audioPlayer = new Audio(audioDataUrl);

                // Set duration from stored value if available
                if (storedDuration) {
                    audioPlayer.duration = parseFloat(storedDuration);
                }

                // Add comprehensive error handling
                audioPlayer.addEventListener('error', (e) => {
                    console.error('Audio playback error:', e);
                    console.error('Audio error details:', audioPlayer.error);
                    console.error('Audio error code:', audioPlayer.error?.code);
                    console.error('Audio error message:', audioPlayer.error?.message);

                    // Show user-friendly error message
                    const errorMessage = audioPlayer.error?.message || 'Audio format not supported';
                    // Update the time display to show duration from stored value
                    if (storedDuration) {
                        const duration = parseFloat(storedDuration);
                        audioTime.textContent = `00:00 / ${formatTime(duration)}`;
                    }

                    // Try alternative audio format if WAV failed
                    if (audioDataUrl.includes('audio/wav') && recordingData && recordingData.length > 0) {
                        const alternativeUrl = `data:audio/mp3;base64,${recordingData}`;
                        const alternativeAudio = new Audio(alternativeUrl);

                        alternativeAudio.addEventListener('canplaythrough', () => {
                            audioPlayer = alternativeAudio;
                            setupAudioEventListeners();
                        }, { once: true });

                        alternativeAudio.addEventListener('error', () => {
                        }, { once: true });

                        alternativeAudio.load();
                    }
                });

                // Setup audio event listeners
                setupAudioEventListeners();
            } else {
            }

            // Helper function to setup audio event listeners
            function setupAudioEventListeners() {
                // Add load event
                audioPlayer.addEventListener('loadeddata', () => {
                    // If duration is still not available, try to set it from stored value
                    if (!audioPlayer.duration || isNaN(audioPlayer.duration)) {
                        if (storedDuration) {
                            audioPlayer.duration = parseFloat(storedDuration);
                        }
                    }
                });

                // Add metadata loaded event
                audioPlayer.addEventListener('loadedmetadata', () => {
                    // If duration is still not available, use stored value
                    if (!audioPlayer.duration || isNaN(audioPlayer.duration)) {
                        if (storedDuration) {
                            audioPlayer.duration = parseFloat(storedDuration);
                        }
                    }
                });

                // Play/Pause functionality
                playBtn.addEventListener('click', async () => {
                    try {
                        if (isPlaying) {
                            audioPlayer.pause();
                            playIcon.textContent = 'play_arrow';
                            isPlaying = false;
                        } else {
                            await audioPlayer.play();
                            playIcon.textContent = 'pause';
                            isPlaying = true;
                        }
                    } catch (error) {
                        console.error('Play/pause error:', error);
                        alert('Error playing audio: ' + error.message);
                    }
                });

                // 5-second backward button
                const backwardBtn = document.getElementById('backwardBtn');
                backwardBtn.addEventListener('click', () => {
                    const newTime = Math.max(0, audioPlayer.currentTime - 5);
                    audioPlayer.currentTime = newTime;
                });

                // 5-second forward button
                const forwardBtn = document.getElementById('forwardBtn');
                forwardBtn.addEventListener('click', () => {
                    const duration = audioPlayer.duration || (storedDuration ? parseFloat(storedDuration) : 0);
                    const newTime = Math.min(duration, audioPlayer.currentTime + 5);
                    audioPlayer.currentTime = newTime;
                });

                // Update progress bar and time
                audioPlayer.addEventListener('timeupdate', () => {
                    let duration = audioPlayer.duration;

                    // Use stored duration if browser can't detect it
                    if (!duration || isNaN(duration) || duration === Infinity) {
                        duration = storedDuration ? parseFloat(storedDuration) : 0;
                    }

                    if (duration && duration > 0 && duration !== Infinity) {
                        const progress = (audioPlayer.currentTime / duration) * 100;
                        audioProgressFill.style.width = progress + '%';

                        const currentTime = formatTime(audioPlayer.currentTime);
                        const totalTime = formatTime(duration);
                        audioTime.textContent = `${currentTime} / ${totalTime}`;
                    } else {
                        // Fallback: show only current time
                        const currentTime = formatTime(audioPlayer.currentTime);
                        audioTime.textContent = `${currentTime}`;
                    }
                });

                // Handle audio end
                audioPlayer.addEventListener('ended', () => {
                    playIcon.textContent = 'play_arrow';
                    isPlaying = false;
                    audioProgressFill.style.width = '0%';
                    if (storedDuration) {
                        audioTime.textContent = `00:00 / ${formatTime(parseFloat(storedDuration))}`;
                    } else {
                        audioTime.textContent = '00:00';
                    }
                });

                // Scrubbing: click, drag and hover preview
                const tooltip = document.getElementById('audioTooltip');
                let isScrubbing = false;

                function getSeekTime(clientX, duration) {
                    const rect = audioProgress.getBoundingClientRect();
                    const x = Math.min(Math.max(clientX - rect.left, 0), rect.width);
                    const ratio = x / rect.width;
                    return { ratio, time: ratio * duration, x: rect.left + x };
                }

                function updateTooltip(clientX, duration) {
                    const { time, x } = getSeekTime(clientX, duration);
                    tooltip.style.display = 'block';
                    tooltip.style.left = clientX + 'px';
                    tooltip.textContent = formatTime(time);
                }

                audioProgress.addEventListener('mousemove', (e) => {
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (storedDuration ? parseFloat(storedDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) updateTooltip(e.clientX, duration);
                });

                audioProgress.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });

                audioProgress.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isScrubbing = true;
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (storedDuration ? parseFloat(storedDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(e.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isScrubbing) return;
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (storedDuration ? parseFloat(storedDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(e.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(e.clientX, duration);
                    }
                });

                window.addEventListener('mouseup', () => {
                    isScrubbing = false;
                });

                // Touch support
                audioProgress.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (storedDuration ? parseFloat(storedDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(touch.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(touch.clientX, duration);
                    }
                }, { passive: true });

                audioProgress.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (storedDuration ? parseFloat(storedDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(touch.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(touch.clientX, duration);
                    }
                }, { passive: true });

                audioProgress.addEventListener('touchend', () => {
                    tooltip.style.display = 'none';
                });

                // Simple click to seek (without dragging)
                audioProgress.addEventListener('click', (e) => {
                    if (!isScrubbing) { // Only if not currently dragging
                        const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                            ? (storedDuration ? parseFloat(storedDuration) : 0)
                            : audioPlayer.duration;
                        if (duration > 0) {
                            const { time, ratio } = getSeekTime(e.clientX, duration);
                            audioPlayer.currentTime = time;
                            audioProgressFill.style.width = (ratio * 100) + '%';
                        }
                    }
                });
            }
        }

        // Function to setup recording player for past conversations
        function setupPastConversationRecording(audioData, audioDuration, audioUrl = null) {
            const recordingPlayer = document.getElementById('recordingPlayer');
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const audioProgress = document.getElementById('audioProgress');
            const audioProgressFill = document.getElementById('audioProgressFill');
            const audioTime = document.getElementById('audioTime');

            console.log('Audio data preview:', audioData ? audioData.substring(0, 100) : 'null');
            console.log('Audio URL:', audioUrl);

            // Priority 1: Check if we have a Supabase Storage URL (for large files)
            if (audioUrl && audioUrl.length > 0) {
                console.log('ðŸ“¤ Using audio from Supabase Storage:', audioUrl);
                recordingPlayer.style.display = 'block';

                // Create audio element from storage URL
                audioPlayer = new Audio(audioUrl);

                // Set duration if available
                if (audioDuration) {
                    audioPlayer.duration = parseFloat(audioDuration);
                }

                // Setup audio event listeners
                setupAudioEventListeners();
                return;
            }

            // Priority 2: Check if we have embedded audio data (for small files)
            if (audioData && audioData.length > 0) {
                // Check if this is placeholder data
                if (audioData === 'YXVkaW9fZGF0YV9wbGFjZWhvbGRlcg==' || audioData === 'audio_data_placeholder') {
                    recordingPlayer.style.display = 'none';
                    return;
                }

                // Check if audio_data contains a Supabase storage reference
                try {
                    const decodedAudioData = atob(audioData);
                    if (decodedAudioData.startsWith('stored_in_supabase_storage:')) {
                        const supabaseUrl = decodedAudioData.replace('stored_in_supabase_storage:', '');
                        console.log('ðŸ“¤ Found Supabase URL in audio_data:', supabaseUrl);

                        // Use the Supabase URL directly
                        recordingPlayer.style.display = 'block';
                        audioPlayer = new Audio(supabaseUrl);

                        if (audioDuration) {
                            audioPlayer.duration = parseFloat(audioDuration);
                        }

                        setupAudioEventListeners();
                        return;
                    }
                } catch (e) {
                    console.log('Audio data is not base64 encoded storage reference');
                }

                // Check if audio data is already a data URL
                let audioDataUrl;
                if (audioData.startsWith('data:audio/')) {
                    // Already a data URL
                    audioDataUrl = audioData;
                } else {
                    // Try to detect the audio format and create proper data URL
                    // First, try to determine if it's base64 encoded
                    const isBase64 = /^[A-Za-z0-9+/]*={0,2}$/.test(audioData);
                    if (isBase64) {
                        // Try different audio formats
                        const audioFormats = [
                            'audio/wav',
                            'audio/mp3',
                            'audio/mpeg',
                            'audio/ogg',
                            'audio/webm',
                            'audio/m4a'
                        ];

                        let audioCreated = false;

                        for (const format of audioFormats) {
                            try {
                                const testUrl = `data:${format};base64,${audioData}`;
                                const testAudio = new Audio(testUrl);

                                testAudio.addEventListener('canplaythrough', () => {
                                    audioDataUrl = testUrl;
                                    audioCreated = true;
                                }, { once: true });

                                testAudio.addEventListener('error', () => {
                                }, { once: true });

                                // Try to load the audio
                                testAudio.load();

                                // Wait a bit to see if it loads
                                setTimeout(() => {
                                    if (!audioCreated) {
                                    }
                                }, 1000);

                            } catch (error) {
                            }
                        }

                        // If no format worked, default to WAV
                        if (!audioCreated) {
                            audioDataUrl = `data:audio/wav;base64,${audioData}`;
                        }
                    } else {
                        // Not base64, might be raw audio data
                        audioDataUrl = `data:audio/wav;base64,${btoa(audioData)}`;
                    }
                }

                recordingPlayer.style.display = 'block';

                // Create audio element from data URL
                audioPlayer = new Audio(audioDataUrl);

                // Set duration from database value if available
                if (audioDuration) {
                    audioPlayer.duration = parseFloat(audioDuration);
                }

                // Add comprehensive error handling
                audioPlayer.addEventListener('error', (e) => {
                    console.error('Audio playback error:', e);
                    console.error('Audio error details:', audioPlayer.error);
                    console.error('Audio error code:', audioPlayer.error?.code);
                    console.error('Audio error message:', audioPlayer.error?.message);

                    // Show user-friendly error message
                    const errorMessage = audioPlayer.error?.message || 'Audio format not supported';
                    // Update the time display to show duration from database value
                    if (audioDuration) {
                        const duration = parseFloat(audioDuration);
                        audioTime.textContent = `00:00 / ${formatTime(duration)}`;
                    }

                    // Try alternative audio format if WAV failed
                    if (audioDataUrl.includes('audio/wav') && audioData && audioData.length > 0) {
                        const alternativeUrl = `data:audio/mp3;base64,${audioData}`;
                        const alternativeAudio = new Audio(alternativeUrl);

                        alternativeAudio.addEventListener('canplaythrough', () => {
                            audioPlayer = alternativeAudio;
                            setupAudioEventListeners();
                        }, { once: true });

                        alternativeAudio.addEventListener('error', () => {
                        }, { once: true });

                        alternativeAudio.load();
                    }
                });

                // Setup audio event listeners
                setupAudioEventListeners();
            } else {
            }

            // Helper function to setup audio event listeners
            function setupAudioEventListeners() {
                // Add load event
                audioPlayer.addEventListener('loadeddata', () => {
                    if (!audioPlayer.duration || isNaN(audioPlayer.duration)) {
                        if (audioDuration) {
                            audioPlayer.duration = parseFloat(audioDuration);
                        }
                    }
                });

                // Add metadata loaded event
                audioPlayer.addEventListener('loadedmetadata', () => {
                    if (!audioPlayer.duration || isNaN(audioPlayer.duration)) {
                        if (audioDuration) {
                            audioPlayer.duration = parseFloat(audioDuration);
                        }
                    }
                });

                // Play/Pause functionality
                playBtn.addEventListener('click', async () => {
                    try {
                        if (isPlaying) {
                            audioPlayer.pause();
                            playIcon.textContent = 'play_arrow';
                            isPlaying = false;
                        } else {
                            await audioPlayer.play();
                            playIcon.textContent = 'pause';
                            isPlaying = true;
                        }
                    } catch (error) {
                        console.error('Play/pause error:', error);
                        alert('Error playing audio: ' + error.message);
                    }
                });

                // 5-second backward button
                const backwardBtn = document.getElementById('backwardBtn');
                backwardBtn.addEventListener('click', () => {
                    const newTime = Math.max(0, audioPlayer.currentTime - 5);
                    audioPlayer.currentTime = newTime;
                });

                // 5-second forward button
                const forwardBtn = document.getElementById('forwardBtn');
                forwardBtn.addEventListener('click', () => {
                    const duration = audioPlayer.duration || (audioDuration ? parseFloat(audioDuration) : 0);
                    const newTime = Math.min(duration, audioPlayer.currentTime + 5);
                    audioPlayer.currentTime = newTime;
                });

                // Update progress bar and time
                audioPlayer.addEventListener('timeupdate', () => {
                    let duration = audioPlayer.duration;

                    // Use database duration if browser can't detect it
                    if (!duration || isNaN(duration) || duration === Infinity) {
                        duration = audioDuration ? parseFloat(audioDuration) : 0;
                    }

                    if (duration && duration > 0 && duration !== Infinity) {
                        const progress = (audioPlayer.currentTime / duration) * 100;
                        audioProgressFill.style.width = progress + '%';

                        const currentTime = formatTime(audioPlayer.currentTime);
                        const totalTime = formatTime(duration);
                        audioTime.textContent = `${currentTime} / ${totalTime}`;
                    } else {
                        // Fallback: show only current time
                        const currentTime = formatTime(audioPlayer.currentTime);
                        audioTime.textContent = `${currentTime}`;
                    }
                });

                // Handle audio end
                audioPlayer.addEventListener('ended', () => {
                    playIcon.textContent = 'play_arrow';
                    isPlaying = false;
                    audioProgressFill.style.width = '0%';
                    if (audioDuration) {
                        audioTime.textContent = `00:00 / ${formatTime(parseFloat(audioDuration))}`;
                    } else {
                        audioTime.textContent = '00:00';
                    }
                });

                // Scrubbing: click, drag and hover preview
                const tooltip = document.getElementById('audioTooltip');
                let isScrubbing = false;

                function getSeekTime(clientX, duration) {
                    const rect = audioProgress.getBoundingClientRect();
                    const x = Math.min(Math.max(clientX - rect.left, 0), rect.width);
                    const ratio = x / rect.width;
                    return { ratio, time: ratio * duration, x: rect.left + x };
                }

                function updateTooltip(clientX, duration) {
                    const { time } = getSeekTime(clientX, duration);
                    tooltip.style.display = 'block';
                    tooltip.style.left = clientX + 'px';
                    tooltip.textContent = formatTime(time);
                }

                audioProgress.addEventListener('mousemove', (e) => {
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (audioDuration ? parseFloat(audioDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) updateTooltip(e.clientX, duration);
                });

                audioProgress.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });

                audioProgress.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isScrubbing = true;
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (audioDuration ? parseFloat(audioDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(e.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isScrubbing) return;
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (audioDuration ? parseFloat(audioDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(e.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(e.clientX, duration);
                    }
                });

                window.addEventListener('mouseup', () => {
                    isScrubbing = false;
                });

                // Touch support
                audioProgress.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (audioDuration ? parseFloat(audioDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(touch.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(touch.clientX, duration);
                    }
                }, { passive: true });

                audioProgress.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                        ? (audioDuration ? parseFloat(audioDuration) : 0)
                        : audioPlayer.duration;
                    if (duration > 0) {
                        const { time, ratio } = getSeekTime(touch.clientX, duration);
                        audioPlayer.currentTime = time;
                        audioProgressFill.style.width = (ratio * 100) + '%';
                        updateTooltip(touch.clientX, duration);
                    }
                }, { passive: true });

                audioProgress.addEventListener('touchend', () => {
                    tooltip.style.display = 'none';
                });

                // Simple click to seek (without dragging)
                audioProgress.addEventListener('click', (e) => {
                    if (!isScrubbing) { // Only if not currently dragging
                        const duration = (!audioPlayer.duration || isNaN(audioPlayer.duration) || audioPlayer.duration === Infinity)
                            ? (audioDuration ? parseFloat(audioDuration) : 0)
                            : audioPlayer.duration;
                        if (duration > 0) {
                            const { time, ratio } = getSeekTime(e.clientX, duration);
                            audioPlayer.currentTime = time;
                            audioProgressFill.style.width = (ratio * 100) + '%';
                        }
                    }
                });
            }
        }

        // Helper function to format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Animate metric bars on page load
        function animateMetrics() {
            const metricFills = document.querySelectorAll('.metric-fill');
            metricFills.forEach((fill, index) => {
                setTimeout(() => {
                    const width = fill.style.width;
                    fill.style.width = '0%';
                    setTimeout(() => {
                        fill.style.width = width;
                    }, 100);
                }, index * 200);
            });
        }

        // Populate transcript and animate when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            populateTranscript();
            setupRecordingPlayer();
            await loadDynamicAnalysis();
            setTimeout(animateMetrics, 500);
        });

        // Function to load dynamic analysis data
        async function loadDynamicAnalysis() {
            try {
                // Get conversation ID from URL parameters or sessionStorage
                const urlParams = new URLSearchParams(window.location.search);
                const urlConversationId = urlParams.get('conversation_id');
                const sessionConversationId = sessionStorage.getItem('conversationId');
                const conversationId = urlConversationId || sessionConversationId;
                // PRIORITY 1: If we have a conversation ID, try to load analysis from database first
                if (conversationId) {
                    try {
                        const analysisResponse = await fetch('/api/db/get_conversation_analysis', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${await getAccessToken()}`
                            },
                            body: JSON.stringify({ conversation_id: conversationId })
                        });

                        if (analysisResponse.ok) {
                            const analysisData = await analysisResponse.json();
                            if (analysisData.success && analysisData.analysis) {
                                updateAnalysisUI(analysisData.analysis);

                                // Set up recording player if available
                                if (analysisData.conversation) {
                                    const audioData = analysisData.conversation.audio_data;
                                    const audioUrl = analysisData.conversation.audio_url;
                                    const audioDuration = analysisData.conversation.audio_duration_seconds;
                                    setupPastConversationRecording(audioData, audioDuration, audioUrl);
                                }

                                return;
                            }
                        }
                    } catch (error) {
                        console.error('Error loading analysis from database:', error);
                        // Continue to other methods
                    }
                }

                // PRIORITY 2: Check if we have existing analysis data (from viewing past analysis)
                const currentAnalysisData = sessionStorage.getItem('currentAnalysisData');
                if (currentAnalysisData) {

                    try {
                        const analysisData = JSON.parse(currentAnalysisData);
                        console.log('Analysis data keys:', Object.keys(analysisData || {}));

                        // Update UI directly - no need to save to database again
                        updateAnalysisUI(analysisData);
                    } catch (parseError) {
                        console.error('Error parsing currentAnalysisData:', parseError);
                        console.error('Raw data that failed to parse:', currentAnalysisData);
                        // Fall back to basic metrics
                        calculateBasicMetrics();
                        return;
                    }

                    // Set up recording player for past conversation
                    if (conversationId) {
                        // Get conversation data to access audio
                        const conversationResponse = await fetch('/api/db/get_conversation_analysis', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${await getAccessToken()}`
                            },
                            body: JSON.stringify({ conversation_id: conversationId })
                        });

                        if (conversationResponse.ok) {
                            const conversationData = await conversationResponse.json();
                            if (conversationData.success && conversationData.conversation) {
                                const audioData = conversationData.conversation.audio_data;
                                const audioUrl = conversationData.conversation.audio_url;
                                const audioDuration = conversationData.conversation.audio_duration_seconds;
                                setupPastConversationRecording(audioData, audioDuration, audioUrl);
                            }
                        }
                    }

                    return;
                }

                // Check if analysis is already saved to database (from success.html)
                const savedAnalysisId = sessionStorage.getItem('analysisId');
                if (savedAnalysisId && conversationId) {
                    // Get analysis from database
                    const analysisResponse = await fetch('/api/db/get_conversation_analysis', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${await getAccessToken()}`
                        },
                        body: JSON.stringify({ conversation_id: conversationId })
                    });

                    if (analysisResponse.ok) {
                        const analysisData = await analysisResponse.json();
                        if (analysisData.success && analysisData.analysis) {
                            updateAnalysisUI(analysisData.analysis);
                            return;
                        }
                    }
                }

                // Check if we have pre-computed analysis data (from success.html)
                const preComputedAnalysis = sessionStorage.getItem('analysisData');
                if (preComputedAnalysis) {
                    const analysisData = JSON.parse(preComputedAnalysis);
                    // Save the pre-computed analysis to database
                    await saveAnalysisToDatabase(analysisData);

                    // Update UI
                    updateAnalysisUI(analysisData);

                    // Clear the pre-computed data to avoid using stale data
                    sessionStorage.removeItem('analysisData');
                    return;
                }

                const transcriptData = sessionStorage.getItem('chatTranscript');
                if (!transcriptData) {
                    calculateBasicMetrics();
                    return;
                }

                const transcript = JSON.parse(transcriptData);

                // Show loading state
                showLoadingState();

                // Step 1: Get conversation ID (should already be saved from main.ts or URL)
                if (!conversationId) {
                    console.error('No conversation ID found! Conversation should have been saved in main.ts or provided in URL');
                    throw new Error('Conversation ID not found. Please try again.');
                }
                // Step 2: Get analysis from OpenAI
                // Get agent information from localStorage
                const selectedAgentId = localStorage.getItem('selectedAgentId');
                const selectedAgentType = localStorage.getItem('selectedAgentType');

                const analysisRequestData = {
                    transcript: transcript,
                    agent_id: selectedAgentId,
                    agent_key: selectedAgentType
                };

                const analysisResponse = await fetch('/analyze_conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(analysisRequestData)
                });

                if (!analysisResponse.ok) {
                    throw new Error(`HTTP error! status: ${analysisResponse.status}`);
                }

                const analysisData = await analysisResponse.json();

                console.log('Analysis data keys:', Object.keys(analysisData || {}));

                // Step 3: Save analysis to database BEFORE updating UI

                const saveAnalysisResponse = await fetch('/api/db/save_analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await getAccessToken()}`
                    },
                    body: JSON.stringify({
                        conversation_id: conversationId,
                        analysis_data: analysisData,
                        analysis_version: "1.0",
                        model_used: "gpt-4o-mini",
                        status: "completed"
                    })
                });

                if (!saveAnalysisResponse.ok) {
                    const errorText = await saveAnalysisResponse.text();
                    console.error('Analysis save error response:', errorText);
                    throw new Error(`Failed to save analysis: ${saveAnalysisResponse.status} - ${errorText}`);
                }

                const saveAnalysisResult = await saveAnalysisResponse.json();
                if (!saveAnalysisResult.success) {
                    throw new Error(`Failed to save analysis: ${saveAnalysisResult.error}`);
                }

                const analysisId = saveAnalysisResult.analysis_id;
                // Store IDs for perfect pitch
                sessionStorage.setItem('conversationId', conversationId);
                sessionStorage.setItem('analysisId', analysisId);

                // Update the UI with dynamic data
                updateAnalysisUI(analysisData);

                // Store analysis data for perfect pitch context
                sessionStorage.setItem('currentAnalysisData', JSON.stringify(analysisData));
            } catch (error) {
                console.error('Error loading dynamic analysis:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
                // Fall back to basic metrics if analysis fails
                calculateBasicMetrics();
            }
        }

        // Function to save analysis to database
        async function saveAnalysisToDatabase(analysisData) {
            try {
                // Get conversation ID (should already exist from main.ts)
                const conversationId = sessionStorage.getItem('conversationId');

                if (!conversationId) {
                    throw new Error('No conversation ID found! Conversation should have been saved in main.ts');
                }
                // Save analysis to database
                const saveAnalysisResponse = await fetch('/api/db/save_analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await getAccessToken()}`
                    },
                    body: JSON.stringify({
                        conversation_id: conversationId,
                        analysis_data: analysisData,
                        analysis_version: "1.0",
                        model_used: "gpt-4o-mini",
                        status: "completed"
                    })
                });
                if (!saveAnalysisResponse.ok) {
                    const errorText = await saveAnalysisResponse.text();
                    console.error('Analysis save error response:', errorText);
                    throw new Error(`Failed to save analysis: ${saveAnalysisResponse.status} - ${errorText}`);
                }

                const saveAnalysisResult = await saveAnalysisResponse.json();
                if (!saveAnalysisResult.success) {
                    throw new Error(`Failed to save analysis: ${saveAnalysisResult.error}`);
                }

                const analysisId = saveAnalysisResult.analysis_id;
                // Store analysis ID for best pitch
                sessionStorage.setItem('analysisId', analysisId);

                return analysisId;

            } catch (error) {
                console.error('Error saving analysis to database:', error);
                throw error;
            }
        }

        // Function to calculate basic metrics when analysis is not available
        function calculateBasicMetrics() {
            const transcriptData = sessionStorage.getItem('chatTranscript');
            if (!transcriptData) {
                return;
            }

            const transcript = JSON.parse(transcriptData);

            // Calculate basic overall score based on conversation length and quality
            let overallScore = 50; // Base score

            // Add points for conversation length (more exchanges = better engagement)
            if (transcript.length >= 10) overallScore += 20;
            else if (transcript.length >= 5) overallScore += 15;
            else if (transcript.length >= 3) overallScore += 10;

            // Add points for user responses (more user messages = better interaction)
            const userMessages = transcript.filter(item => item.sender === 'You').length;
            if (userMessages >= 5) overallScore += 15;
            else if (userMessages >= 3) overallScore += 10;
            else if (userMessages >= 1) overallScore += 5;

            // Add points for conversation duration (longer = more engagement)
            let totalSeconds = 0;
            transcript.forEach(item => {
                const timeParts = item.time.split(':');
                if (timeParts.length === 2) {
                    const minutes = parseInt(timeParts[0]);
                    const seconds = parseInt(timeParts[1]);
                    totalSeconds = Math.max(totalSeconds, minutes * 60 + seconds);
                }
            });

            if (totalSeconds >= 300) overallScore += 10; // 5+ minutes
            else if (totalSeconds >= 180) overallScore += 8; // 3+ minutes
            else if (totalSeconds >= 60) overallScore += 5; // 1+ minute

            // Cap the score at 100
            overallScore = Math.min(overallScore, 100);

            // Update overall score
            const scoreValue = document.getElementById('overallScore');
            if (scoreValue) {
                scoreValue.textContent = `Overall Score: ${overallScore}%`;
            }

            // Update confidence level
            const confidenceEl = document.getElementById('sessionConfidence');
            if (confidenceEl) {
                const confidence = Math.min(overallScore + 10, 100);
                confidenceEl.textContent = `Confidence: ${confidence}%`;
                confidenceEl.style.color = confidence >= 80 ? '#10b981' :
                    confidence >= 60 ? '#f59e0b' : '#ef4444';
            }

            // Calculate basic voice metrics
            const basicVoiceMetrics = {
                grammar_clarity: { score: Math.min(overallScore + 5, 100) },
                fluency_flow: { score: Math.min(overallScore + 3, 100) },
                confidence_level: { score: Math.min(overallScore + 2, 100) },
                speaking_pace: { score: Math.min(overallScore + 7, 100) },
                enthusiasm: { score: Math.min(overallScore + 4, 100) },
                message_clarity: { score: Math.min(overallScore + 6, 100) }
            };

            // Calculate basic sales skills
            const basicSalesSkills = {
                introduction_quality: { stars: Math.ceil(overallScore / 20), score: Math.min(overallScore / 20, 5) },
                need_analysis: { stars: Math.ceil(overallScore / 25), score: Math.min(overallScore / 25, 5) },
                objection_handling: { stars: Math.ceil(overallScore / 22), score: Math.min(overallScore / 22, 5) },
                closing_skills: { stars: Math.ceil(overallScore / 30), score: Math.min(overallScore / 30, 5) }
            };

            // Calculate basic sales process flow
            const basicSalesProcess = {
                introduction: { status: 'completed', score: Math.min(overallScore + 10, 100) },
                discovery: { status: userMessages >= 2 ? 'completed' : 'partial', score: Math.min(overallScore + 5, 100) },
                presentation: { status: 'partial', score: Math.min(overallScore + 3, 100) },
                objection_handling: { status: 'partial', score: Math.min(overallScore + 8, 100) },
                close: { status: 'missed', score: Math.min(overallScore - 10, 100) }
            };

            // Generate basic insights
            const basicStrengths = [
                'Engaged in conversation with the prospect',
                'Maintained professional communication',
                'Responded to questions and concerns'
            ];

            const basicImprovements = [
                'Practice more discovery questions',
                'Work on objection handling techniques',
                'Develop stronger closing skills',
                'Improve overall conversation flow'
            ];

            // Update UI with basic metrics
            updateVoiceAnalysis(basicVoiceMetrics);
            updateSalesSkills(basicSalesSkills);
            updateSalesProcess(basicSalesProcess);
            updateInsights(basicStrengths, basicImprovements);
        }

        // Function to show loading state
        function showLoadingState() {
            // Add loading indicators to key sections
            const sections = document.querySelectorAll('.analysis-section, .insights-section, .conversation-flow');
            sections.forEach(section => {
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading-indicator';
                loadingDiv.innerHTML = '<div class="loading-spinner"></div><p>Analyzing conversation...</p>';
                loadingDiv.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    padding: 40px;
                    color: #64748b;
                `;
                section.appendChild(loadingDiv);
            });
        }

        // Function to update UI with dynamic analysis data
        function updateAnalysisUI(data) {

            console.log('Data keys:', Object.keys(data || {}));

            // Remove loading indicators
            document.querySelectorAll('.loading-indicator').forEach(el => el.remove());

            // Check if data is valid
            if (!data || typeof data !== 'object') {
                console.error('Invalid analysis data received:', data);
                calculateBasicMetrics();
                return;
            }

            // Debug each section

            updateSessionInfo(data.session_info);

            updateOverallScore(data.overall_score);

            updateKeyMetrics(data.key_metrics);

            updateVoiceAnalysis(data.voice_delivery_analysis);

            updateSalesSkills(data.sales_skills_assessment);

            updateSalesProcess(data.sales_process_flow);

            updateInsights(data.strengths, data.improvements);
        }

        // Update session information
        function updateSessionInfo(sessionInfo) {
            const sessionTitleEl = document.getElementById('sessionTitle');
            const sessionTypeEl = document.getElementById('sessionType');
            const sessionStageEl = document.getElementById('sessionStage');
            const sessionRoleEl = document.getElementById('sessionRole');
            const sessionConfidenceEl = document.getElementById('sessionConfidence');
            const sessionDurationEl = document.getElementById('sessionDuration');
            const sessionExchangesEl = document.getElementById('sessionExchanges');
            
            // Check if sessionInfo is valid
            if (!sessionInfo || typeof sessionInfo !== 'object') {
                return;
            }

            // Update title in main content
            if (sessionTitleEl && sessionInfo.scenario_type) {
                sessionTitleEl.textContent = `${sessionInfo.scenario_type} Training Session`;
            } else if (sessionTitleEl) {
                sessionTitleEl.textContent = 'Sales Training Session';
            }

            // Update type in main content
            if (sessionTypeEl && sessionInfo.prospect_role) {
                sessionTypeEl.textContent = `${sessionInfo.prospect_role} Conversation`;
            } else if (sessionTypeEl) {
                sessionTypeEl.textContent = 'Sales Conversation';
            }

            // Update stage in main content
            if (sessionStageEl && sessionInfo.conversation_stage) {
                sessionStageEl.textContent = `Stage: ${sessionInfo.conversation_stage}`;
            } else if (sessionStageEl) {
                sessionStageEl.textContent = 'Stage: --';
            }

            // Update role in main content
            if (sessionRoleEl && sessionInfo.prospect_role) {
                sessionRoleEl.textContent = `Role: ${sessionInfo.prospect_role}`;
            } else if (sessionRoleEl) {
                sessionRoleEl.textContent = 'Role: --';
            }

            // Update confidence in main content
            if (sessionConfidenceEl && sessionInfo.confidence_level !== undefined) {
                sessionConfidenceEl.textContent = `Confidence: ${sessionInfo.confidence_level}%`;
                sessionConfidenceEl.style.color = sessionInfo.confidence_level >= 80 ? '#10b981' :
                    sessionInfo.confidence_level >= 60 ? '#f59e0b' : '#ef4444';
            } else if (sessionConfidenceEl) {
                sessionConfidenceEl.textContent = 'Confidence: --';
            }

            // Update duration in sidebar
            if (sessionDurationEl && sessionInfo.duration_minutes !== undefined) {
                const minutes = Math.floor(sessionInfo.duration_minutes);
                const seconds = Math.round((sessionInfo.duration_minutes - minutes) * 60);
                sessionDurationEl.textContent = `Duration: ${minutes}m ${seconds}s`;
            } else if (sessionDurationEl) {
                sessionDurationEl.textContent = 'Duration: --';
            }

            // Update exchanges in sidebar
            if (sessionExchangesEl && sessionInfo.total_exchanges !== undefined) {
                sessionExchangesEl.textContent = `Exchanges: ${sessionInfo.total_exchanges}`;
            } else if (sessionExchangesEl) {
                sessionExchangesEl.textContent = 'Exchanges: --';
            }
        }

        // Update overall score
        function updateOverallScore(overallScore) {
            const scoreValue = document.getElementById('overallScore');
            // Check if overallScore is valid
            if (!overallScore || typeof overallScore !== 'object') {
                if (scoreValue) {
                    scoreValue.textContent = 'Overall Score: --';
                }
                return;
            }

            if (scoreValue && overallScore.percentage !== undefined) {
                scoreValue.textContent = `Overall Score: ${overallScore.percentage}%`;
            } else {

                if (scoreValue) {
                    scoreValue.textContent = 'Overall Score: --';
                }
            }
        }

        // Update key metrics
        function updateKeyMetrics(keyMetrics) {
            const metricCards = document.querySelectorAll('.metric-card');
            metricCards.forEach(card => {
                const valueEl = card.querySelector('.metric-value');
                const labelEl = card.querySelector('.metric-label');

                if (card.classList.contains('conversation-time') && keyMetrics.conversation_time) {
                    valueEl.textContent = keyMetrics.conversation_time;
                } else if (card.classList.contains('exchanges') && keyMetrics.exchanges) {
                    valueEl.textContent = keyMetrics.exchanges;
                } else if (card.classList.contains('avg-response') && keyMetrics.avg_response_time) {
                    valueEl.textContent = keyMetrics.avg_response_time;
                }
            });
        }

        // Update voice delivery analysis
        function updateVoiceAnalysis(voiceAnalysis) {
            const metrics = [
                { id: 'grammarMetric', key: 'grammar_clarity', class: 'grammar' },
                { id: 'fluencyMetric', key: 'fluency_flow', class: 'fluency' },
                { id: 'confidenceMetric', key: 'confidence_level', class: 'hesitation' },
                { id: 'paceMetric', key: 'speaking_pace', class: 'pace' },
                { id: 'enthusiasmMetric', key: 'enthusiasm', class: 'enthusiasm' },
                { id: 'clarityMetric', key: 'message_clarity', class: 'clarity' }
            ];

            metrics.forEach(metric => {
                const metricEl = document.getElementById(metric.id);
                if (metricEl) {
                    const fillEl = metricEl.querySelector('.metric-fill');
                    const valueEl = metricEl.querySelector('.metric-value-detailed');

                    if (voiceAnalysis[metric.key] && voiceAnalysis[metric.key].score !== undefined) {
                        const score = voiceAnalysis[metric.key].score;
                        fillEl.style.width = `${score}%`;
                        valueEl.textContent = `${score}%`;
                    }
                }
            });
        }

        // Update sales skills assessment
        function updateSalesSkills(salesSkills) {
            const ratings = [
                { id: 'introRating', key: 'introduction_quality' },
                { id: 'needAnalysisRating', key: 'need_analysis' },
                { id: 'objectionRating', key: 'objection_handling' },
                { id: 'closingRating', key: 'closing_skills' }
            ];

            ratings.forEach(rating => {
                const ratingEl = document.getElementById(rating.id);
                if (ratingEl) {
                    const starsEl = ratingEl.querySelector('.star-rating');
                    const scoreEl = ratingEl.querySelector('.rating-score');

                    if (salesSkills[rating.key] && salesSkills[rating.key].stars !== undefined) {
                        const stars = salesSkills[rating.key].stars;
                        const score = salesSkills[rating.key].score || stars;

                        // Update stars
                        const starElements = starsEl.querySelectorAll('.star');
                        starElements.forEach((star, index) => {
                            if (index < stars) {
                                star.classList.add('filled');
                            } else {
                                star.classList.remove('filled');
                            }
                        });

                        // Update score
                        scoreEl.textContent = score;
                    }
                }
            });
        }

        // Update sales process flow
        function updateSalesProcess(salesProcess) {
            const steps = [
                { id: 'introStep', key: 'introduction' },
                { id: 'discoveryStep', key: 'discovery' },
                { id: 'presentationStep', key: 'presentation' },
                { id: 'objectionStep', key: 'objection_handling' },
                { id: 'closeStep', key: 'close' }
            ];

            steps.forEach(step => {
                const stepEl = document.getElementById(step.id);
                if (stepEl) {
                    const scoreEl = stepEl.querySelector('.flow-score');
                    const iconEl = stepEl.querySelector('.flow-icon');

                    if (salesProcess[step.key] && salesProcess[step.key].status && salesProcess[step.key].score !== undefined) {
                        const status = salesProcess[step.key].status;
                        const score = salesProcess[step.key].score;

                        // Update status classes
                        stepEl.className = `flow-step ${status}`;

                        // Update score
                        scoreEl.textContent = `${score}%`;

                        // Update icon background based on status
                        if (status === 'completed') {
                            iconEl.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
                        } else if (status === 'partial') {
                            iconEl.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                        } else {
                            iconEl.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                        }
                    }
                }
            });
        }

        // Update insights
        function updateInsights(strengths, improvements) {
            // Update strengths
            const strengthsList = document.getElementById('strengthsList');
            if (strengthsList && strengths && strengths.length > 0) {
                strengthsList.innerHTML = '';
                strengths.forEach(strength => {
                    const li = document.createElement('li');
                    li.textContent = strength;
                    strengthsList.appendChild(li);
                });
            }

            // Update improvements
            const improvementsList = document.getElementById('improvementsList');
            if (improvementsList && improvements && improvements.length > 0) {
                improvementsList.innerHTML = '';
                improvements.forEach(improvement => {
                    const li = document.createElement('li');
                    li.textContent = improvement;
                    improvementsList.appendChild(li);
                });
            }
        }

        // Handle Perfect Pitch button
        document.getElementById('perfectPitchBtn').addEventListener('click', async () => {
            const transcriptData = sessionStorage.getItem('chatTranscript');
            if (!transcriptData) {
                alert('No conversation transcript found.');
                return;
            }

            const transcript = JSON.parse(transcriptData);
            const modal = document.getElementById('perfectPitchModal');
            const modalContent = document.getElementById('modalContent');
            const btn = document.getElementById('perfectPitchBtn');

            // Try to get any existing analysis data for context
            const analysisData = sessionStorage.getItem('currentAnalysisData') || sessionStorage.getItem('analysisData');
            let requestBody = { transcript: transcript };

            if (analysisData) {
                try {
                    requestBody.analysis_data = JSON.parse(analysisData);
                    console.log('Analysis context:', JSON.parse(analysisData).overall_score);
                } catch (e) {
                }
            }

            // Show modal with loading state
            modal.classList.add('show');
            btn.disabled = true;
            btn.innerHTML = '<span class="material-icons">hourglass_empty</span>Generating...';

            try {
                // Step 1: Check if best pitch exists
                const conversationId = sessionStorage.getItem('conversationId');
                const analysisId = sessionStorage.getItem('analysisId');

                if (!conversationId || !analysisId) {
                    throw new Error('Missing conversation or analysis ID');
                }

                const checkResponse = await fetch('/api/db/check_best_pitch_exists', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await getAccessToken()}`
                    },
                    body: JSON.stringify({ conversation_id: conversationId })
                });

                if (!checkResponse.ok) {
                    console.error('Check response error:', checkResponse.status, checkResponse.statusText);
                    const errorText = await checkResponse.text();
                    console.error('Error response body:', errorText);
                    throw new Error(`Best pitch check failed: ${checkResponse.status} - ${errorText}`);
                }

                const checkResult = await checkResponse.json();
                let perfectPitchData;

                if (checkResult.success && checkResult.exists) {
                    perfectPitchData = checkResult.data;
                } else {
                    // Step 2: Generate new best pitch
                    const response = await fetch('/best-pitch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    perfectPitchData = await response.json();
                    // Step 3: Save best pitch to database

                    const saveResponse = await fetch('/api/db/save_best_pitch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${await getAccessToken()}`
                        },
                        body: JSON.stringify({
                            conversation_id: conversationId,
                            analysis_id: analysisId,
                            best_pitch_data: perfectPitchData,
                            original_conversation: getConversationHistory(),
                            model_used: "gpt-4o-mini",
                            generation_version: "1.0",
                            status: "completed"
                        })
                    });

                    if (!saveResponse.ok) {
                        throw new Error(`Failed to save best pitch: ${saveResponse.status}`);
                    }

                    const saveResult = await saveResponse.json();
                    if (!saveResult.success) {
                        throw new Error(`Failed to save best pitch: ${saveResult.error}`);
                    }
                }

                // Update modal content with perfect pitch data
                displayPerfectPitch(perfectPitchData);

            } catch (error) {
                console.error('Error generating perfect pitch:', error);

                // Try to get more detailed error information
                let errorMessage = 'We are experiencing high demand right now. Please try again after some time.';
                let debugInfo = '';

                if (error.message) {
                    errorMessage = error.message;
                }

                // If it's a fetch error, try to get response details
                if (error instanceof TypeError && error.message.includes('fetch')) {
                    errorMessage = 'Network error. Please check your connection and try again after some time.';
                }
                modalContent.innerHTML = `
                    <div class="loading-perfect-pitch">
                        <span class="material-icons" style="font-size: 48px; color: #ef4444; margin-bottom: 16px;">error</span>
                        <h3 style="color: #1e293b; margin-bottom: 8px;">Service Temporarily Unavailable</h3>
                        <p style="color: #64748b; margin-bottom: 16px;">${errorMessage}</p>
                `;
            } finally {
                // Reset button
                btn.disabled = false;
                btn.innerHTML = '<span class="material-icons">auto_awesome</span>Get Perfect Pitch';
            }
        });

        // Handle modal close
        document.getElementById('modalClose').addEventListener('click', () => {
            document.getElementById('perfectPitchModal').classList.remove('show');
        });

        // Close modal when clicking overlay
        document.getElementById('perfectPitchModal').addEventListener('click', (e) => {
            if (e.target.id === 'perfectPitchModal') {
                document.getElementById('perfectPitchModal').classList.remove('show');
            }
        });

        // Helper functions for database operations
        async function refreshAccessToken() {
            const refreshToken = localStorage.getItem('refreshToken');
            if (!refreshToken) {
                console.error('No refresh token found');
                return null;
            }

            try {
                const response = await fetch('/auth/refresh', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        refresh_token: refreshToken
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    localStorage.setItem('accessToken', data.access_token);
                    localStorage.setItem('refreshToken', data.refresh_token);
                    localStorage.setItem('tokenExpiresAt', data.expires_at);
                    return data.access_token;
                } else {
                    console.error('Failed to refresh token');
                    return null;
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
                return null;
            }
        }

        async function getAccessToken() {
            // Get access token from sessionStorage or localStorage
            let token = sessionStorage.getItem('accessToken') || localStorage.getItem('accessToken');

            if (!token) {
                console.error('No access token found, redirecting to login');
                window.location.href = '/login.html';
                return '';
            }

            // Check if token is expired
            const expiresAt = localStorage.getItem('tokenExpiresAt');
            if (expiresAt) {
                const expirationTime = new Date(expiresAt).getTime();
                const currentTime = new Date().getTime();
                const isExpired = currentTime >= (expirationTime - 5 * 60 * 1000); // 5 minutes buffer

                if (isExpired) {
                    const newToken = await refreshAccessToken();
                    if (newToken) {
                        token = newToken;
                    } else {
                        console.error('Failed to refresh token, redirecting to login');
                        localStorage.clear();
                        window.location.href = '/login.html';
                        return '';
                    }
                }
            }

            return token;
        }

        function getCallDuration() {
            const startTime = sessionStorage.getItem('callStartTime');
            if (startTime) {
                return Math.floor((Date.now() - parseInt(startTime)) / 1000);
            }
            return 180; // Default 3 minutes
        }

        function getConversationHistory() {
            const transcript = sessionStorage.getItem('chatTranscript');
            if (transcript) {
                return JSON.parse(transcript);
            }
            return [];
        }

        function getAudioDuration() {
            return getCallDuration();
        }

        function getBase64Audio() {
            return sessionStorage.getItem('conversationRecording') || null;
        }

        // Function to display perfect pitch data in modal
        function displayPerfectPitch(data) {
            const modalContent = document.getElementById('modalContent');

            let html = `
                <div class="improvement-summary">
                    <div class="score-comparison">
                        <div class="score-item">
                            <div class="score-label">Original Score</div>
                            <div class="score-value original">${data.score_improvement?.original_score || 0}%</div>
                        </div>
                        <div class="score-item">
                            <div class="score-label">Perfect Score</div>
                            <div class="score-value perfect">${data.score_improvement?.perfect_score || 0}%</div>
                        </div>
                        <div class="score-item">
                            <div class="score-label">Improvement</div>
                            <div class="score-value improvement">+${data.score_improvement?.improvement || 0}%</div>
                        </div>
                    </div>
                    
                    <h3 style="font-size: 18px; font-weight: 600; color: #1e293b; margin-bottom: 16px;">Key Improvements</h3>
                    <ul class="improvements-list">
            `;

            if (data.overall_improvements && data.overall_improvements.length > 0) {
                data.overall_improvements.forEach(improvement => {
                    html += `<li>${improvement}</li>`;
                });
            }

            html += `
                    </ul>
                </div>
                
                <div class="conversation-comparison">
                    <h3 style="font-size: 20px; font-weight: 600; color: #1e293b; margin-bottom: 24px;">Perfect Conversation Comparison</h3>
            `;

            if (data.perfect_conversation && data.perfect_conversation.length > 0) {
                data.perfect_conversation.forEach(exchange => {
                    if (exchange.speaker === 'AI') {
                        // AI messages - show as single block
                        html += `
                            <div class="ai-message">
                                <div class="ai-message-label">AI Prospect Response</div>
                                <div class="ai-message-text">${exchange.original_text}</div>
                            </div>
                        `;
                    } else {
                        // User messages - show comparison
                        html += `
                            <div class="exchange-item">
                                <div class="exchange-header">
                                    <div class="exchange-title">Exchange ${exchange.exchange_number}</div>
                                    <div class="exchange-speaker">Your Response</div>
                                </div>
                                <div class="exchange-content">
                                    <div class="original-response">
                                        <div class="response-label">What You Said</div>
                                        <div class="response-text">${exchange.original_text}</div>
                                    </div>
                                    <div class="perfect-response">
                                        <div class="response-label">Perfect Response</div>
                                        <div class="response-text">${exchange.perfect_text}</div>
                                        ${exchange.improvement_reason ? `<div class="improvement-reason">${exchange.improvement_reason}</div>` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });
            }

            html += `
                </div>
            `;

            modalContent.innerHTML = html;
        }
    </script>
</body>

</html>